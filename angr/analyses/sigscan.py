from . import Analysis, register_analysis
import nampa
import os

import logging
l = logging.getLogger('angr.analyses.sigscan')

class Match:
    def __init__(self, func, addr, kb, binary):
        self.match_sym_name = False
        self.match_sym_addr = False
        self.match_kb       = False
        self.flirtfunc      = func
        self.flirtaddr      = addr | binary.mapped_base

        self.check_symbols()
        self.check_kb()

    def check_symbols(self):
        sym = binary.get_symbol(self.flirtfunc.name)
        if sym is not None:
            self.match_sym_name = True
        if self.flirtaddr in mainobj.symbols_by_addr:
            self.match_sym_addr = True

    def check_kb(self):
        if self.flirtaddr in kb.functions:
            self.match_kb = True

# TODO: Add a `register_sig_scan` to keep a dict of supported classes

class SigScan(Analysis):
    """
    Base class for signature scanning
    """
    def __init__(self, method, rename=False, binary=None, cfg=None, use_sym=True, \
                 use_kb=True, use_cfg_nodes=False, addrs=[], exclude=[], **kwargs):
        """
        :param method:          The type of signature scan to do
        :param rename:          Whether or not to automatically rename matched functions in the kb.
                                Defaults to False.
        :param binary:          The binary to analyze. Defaults to the project's main_object.
        :param cfg:             The CFG to use, if applicable.
        :param kwargs:          This is passed directly to child class constructors.
        :param use_sym:         Whether or not to scan all functions in the binary's symbols
        :param use_kb:          Whether or not to scan all non-SimProcedure, non-Syscall functions in the kb.
                                Note that this also excludes all hooked functions since they are SimProcedures.
        :param use_cfg_nodes:   Whether or not to scan all *unnamed* nodes in the CFG
        :param addrs:           A ``list`` of addresses to scan.
        :param exclude:         A ``list`` of addresses to exclude from the list of addresses
                                generated by other options. I.e., they are excluded only if
                                otherwise identified as functions; they are not actively avoided
                                if they happen to fall within the address range of a function.
        """
        self.method         = method.lower()
        self.rename         = rename
        self.binary         = binary if binary is not None else self.project.loader.main_object
        self.cfg            = cfg if cfg is not None else self.project.cfg if hasattr(self.project, 'cfg') else None
        self.use_sym        = use_sym
        self.use_kb         = use_kb
        self.use_cfg_nodes  = use_cfg_nodes
        self.user_addrs     = addrs
        self.exclude_addrs  = exclude

        self.bs      = self.binary.binary_stream
        self.scanner = None

        if method == 'flirt':
            self.scanner = FlirtScan(**kwargs)
            self.scan()

    @property
    def matches(self):
        return self.scanner.matches

    @property
    def sym_func_addrs(self):
        """
        Returns a list of addresses: every function in the binary's symbols
        """
        return [k for k,v in self.binary.symbols_by_addr if v.is_function is True]

    @property
    def kb_func_addrs(self):
        """
        Returns a list of addresses: every function in the KnowledgeBase excluding SimProcedures and SysCalls.
        """
        if not hasattr('functions', self.kb):
            l.warn('No functions in KnowledgeBase. Try running a CFG.')
            return []
        return [k for k,v in self.kb.functions if not v.is_syscall and not v.is_simprocedure]

    @property
    def cfg_unnamed_node_addrs(self):
        """
        Returns a list of addresses: every node in the CFG that is unnamed (not part of a function)
        """
        return [f.addr for f in self.nodes() if f.name is None ]

    def _get_addrs(self):
        """
        Returns the complete, sorted list of all addresses to scan based on provided options
        """
        sym_addrs       = []
        cfg_node_addrs  = []

        if kwargs.get('use_sym', False) is True:
            sym_addrs = self.sym_func_addrs()
        if kwargs.get('use_kb', False) is True:
            kb_addrs = self.kb_func_addrs()
        if kwargs.get('use_cfg_nodes', False) is True:
            cfg_node_addrs = self.cfg_unnamed_node_addrs()

        return sorted(set(self.user_addrs + self.exclude_addrs + self.sym_func_addrs \
                          + self.kb_func_addrs + self.cfg_unnamed_node_addrs) - set(exclude_addrs))

    def scan(self):
        """
        Initiates the scan and returns a list of any matches found.
        ..warning::
           This method must be overridden in derived classes.
        """
        self.scanner.scan()
        return self.matches

# TODO: HACK for nampa
# The callback from nampa has to be a static method so we
# keep a reference to the currently-running instance. We should
# probably just put in a PR to add the ability to pass an
# additional parameter, and we can pass the instance there
# flirtinstance = None

# TODO: Make most of this static so it can be run on an arbitrary binary
class FlirtScan(SigScan):
    """
    .. |nampa| replace:: :mod:`nampa`
    A wrapper around nampa to provide FLIRT signature scanning.
    """
    def __init__(self, **kwargs):
        """
        :param kwargs:  Options to control the scan. See below.

        .. |nampa| replace:: :mod:`nampa`
        :Keyword Arguments:
            * *callback* --
                A function nampa calls for every match. Must be ``callback(addr, func)``.
                Defaults to ``_nampa_callback``. This is used internally and should only
                be specified if you wish to handle matches manually.
            * *sigpath* --
                Path to a FLIRT signature file or a directory. If a directory, only
                files ending with `.sig` are considered.
                Defaults to ``os.getcwd()``.

        """
        self.matches    = []
        self.callback   = kwargs.get('callback', _nampa_callback)
        self.signatures = self.load_signatures(kwargs.get('sigpath', os.getcwd()))
        self.addrlist   = self.get_addrs()

        FlirtScan._cur_instance = self      # Bit of a hack for nampa. See above.

    #
    # Static vars
    #
    _cur_instance   = None
    _FUNCTION_TAIL_LENGTH = 0x100

    @staticmethod
    def _nampa_callback(addr, func):
        match = Match(func, addr, flirtinstance.project)
        FlirtScan._cur_instance.matches.append(match)

    def scan(self):
        self._match_addrs(self.addrs)

    def _load_signatures(self):
        sigfiles = []
        if os.path.isfile(sigpath):
            sigfiles.append(sigpath)
        elif os.path.isdir(sigpath):
            sigfiles.extend([os.path.join(sigpath, f) for f in next(os.walk(sigpath))[2] if f.endswith('.sig')])

        signatures = []
        for sf in sigfiles:
            with open(sf, 'rb') as sigfile:
                signatures.append(nampa.parse_flirt_file(sigfile))

        return signatures

    def _match_addrs(self):
        for s in self.signatures:
            l.debug('Scanning %d addresses with SIG for %s', len(self.addrlist), s.header.library_name)
            for addr in self.addrlist:
                start = addr ^ self.obj.mapped_base
                end = addr + 32
                self.bs.seek(start, 0)
                buf = self.bs.read(end - start + FlirtScan._FUNCTION_TAIL_LENGTH)
                nampa.match_functions(s, buf, start, self.callback)


register_analysis(SigScan, 'SigScan')
