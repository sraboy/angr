from . import Analysis, register_analysis
import nampa
import os
import logging
import operator

l = logging.getLogger('angr.analyses.sigscan')

class Match:
    """
    Defines a positive match, or 'find', from a signature scan
    """
    def __init__(self, funcname, funcaddr, kb, backend, rename_kb, duplicate, flirtfunc):
        """
        :param funcname:    The name of the matched function
        :param funcaddr:    The address of the matched function
        :param kb:          The Angr KnowledgeBase containing functions
        :param backend:     The CLE backend containing symbols
        :param rename_kb:   Whether or not to rename the kb entry for this function to `funcname`
        """
        self.match_sym_name = False
        self.match_sym_addr = False
        self.match_kb       = False
        self.funcname       = funcname
        self.funcaddr       = funcaddr      # TODO: change this to include mapped_base. Can use flirtfunc otherwise.
        self.kb             = kb
        self.backend        = backend
        self.duplicate      = duplicate
        self.flirtfunc      = flirtfunc
        #self.kbfunc         = None

        if self.backend is not None:
            self._check_symbols()
        if self.kb is not None:
            self._check_kb()

        if rename_kb:
            self.try_rename()

    def _check_symbols(self):
        sym = self.backend.get_symbol(self.funcname)
        if sym is not None:
            self.match_sym_name = True
        if self.funcaddr + self.backend.mapped_base in self.backend.symbols_by_addr:
            self.match_sym_addr = True

    @property
    def kb_func(self):
        if self.funcaddr + self.backend.mapped_base in self.kb.functions:
            return self.kb.functions[self.funcaddr + self.backend.mapped_base]
        #else
        #    l.error('No KB func found for %s at 0x%04x', self.funcname, self.funcaddr + self.backend.mapped_base)
            return None

    def _check_kb(self):
        if self.funcaddr + self.backend.mapped_base in self.kb.functions:
            self.match_kb = True
            self.kbfunc = self.kb.functions[self.funcaddr + self.backend.mapped_base]
        #else:
        #    self.match_kb = False
        #    self.kbfunc = self.kb.functions.function(addr=(self.funcaddr + self.backend.mapped_base), create=True)
        #    self.kbfunc.name = self.funcname

    def try_rename(self):
        if self.match_kb:
            if self.duplicate:
                l.warn('DUPLICATE. Skipping rename of %s at %08x', self.funcname, self.funcaddr)
                return
            f = self.kb.functions[self.funcaddr + self.backend.mapped_base]
            if f.name != self.funcname:
                f.name = self.funcname
                l.debug('Renamed %s to %s', f.name, self.funcname)
        else:
            l.warn('Function %s not in KB. Skipping rename.', self.funcname)


class SigScan(Analysis):
    """
    Angr Analysis base class for signature scanning. It provides default values to the signature scanners
    based on the current project, or as specified.
    """
    def __init__(self, method, rename=False, backend=None, cfg=None, use_sym=True, \
                 use_kb=True, use_cfg_nodes=False, addrs=[], exclude=[], doscan=True, **kwargs):
        """
        :param method:          The type of signature scan to do
        :param rename:          Whether or not to automatically rename matched functions in the kb. Defaults to False.
        :param backend:         The CLE backend to analyze. Defaults to the project's main_object.
        :param cfg:             The CFG to use, if applicable. Defaults to None `project.cfg`, if it exists,
                                or None otherwise.
        :param use_sym:         Whether or not to include all functions in the backend's symbols in scanning
        :param use_kb:          Whether or not to include all non-SimProcedure, non-Syscall functions from the kb in
                                scanning.
        :param use_cfg_nodes:   Whether or not to include all *unnamed* nodes in the CFG in scanning
        :param addrs:           A ``list`` of addresses to scan.
        :param exclude:         A ``list`` of node/function addresses to remove from the list of addresses generated by
                                other options. They are only relevant if they are a function's start address or, if
                                use_cfg_nodes==True, a node's address; they are not "avoided" during scanning.
        :param doscan:          Whether or not to immediately start the scan
        :param kwargs:          Params passed directly to child classes
        """
        self.rename         = rename
        self.backend        = backend if backend is not None else self.project.loader.main_object
        self.cfg            = cfg
        self.use_sym        = use_sym
        self.use_kb         = use_kb
        self.use_cfg_nodes  = use_cfg_nodes
        self.user_addrs     = addrs
        self.exclude_addrs  = exclude

        self.bs             = self.backend.binary_stream
        self.scanner        = None

        if self.cfg is None:
            l.warn('No CFG provided. Generating CFGFast w/ any additional function_starts from addrs.')
            if self.project is None:
                l.error('There is no project and a CFG was not provided')
            self.cfg = self.project.analyses.CFGFast(function_starts=self.user_addrs) # TODO: Remove exclude_addrs from this list
            l.warn('Using KB generated by CFG')
            self.kb = self.cfg.kb

        # We need a CFG, which has a KB, so this isn't relevant until/unless we implement generating results
        # without a CFG, meaning some functions may not be identified properly.
        #if self.use_sym and not self.kb:
        #    self.use_sym = False
        #    l.warn('No KB found. Ignoring use_sym.')
        #if self.use_kb and not self.kb:
        #    self.use_kb = False
        #    l.warn('No KB found. Ignoring use_kb.')

        try:
            ScanClass = registered_signature_scanners[method.lower()]
            self.scanner = ScanClass(addrlist=self._get_addrs(),
                                     funclist=self._get_funcs(),
                                     bs=self.bs,
                                     rename=self.rename,
                                     kb=self.kb,
                                     cfg=self.cfg,
                                     backend=self.backend,
                                     offset=self.backend.mapped_base,
                                     **kwargs)
        except KeyError:
            l.error("Unknown signature scanner (%s). Registered scanners: %s", method, registered_signature_scanners.keys())
            raise

        if doscan:
            self.scan()

    @property
    def matches(self):
        if self.scanner is not None:
            return self.scanner.matches
        else:
            l.warn('There is no scanner, Neo.')

    @property
    def sym_func_addrs(self):
        """
        Returns a list of addresses: every function in the binary's symbols
        """
        if self.backend is None:
            return []

        return [k for k,v in self.backend.symbols_by_addr.items() if v.is_function is True]

    @property
    def kb_func_addrs(self):
        """
        Returns a list of addresses: every function in the KnowledgeBase excluding SimProcedures and SysCalls.
        """
        if self.kb is None:
            return []

        if not hasattr(self.kb, 'functions'):
            l.warn('No functions in KnowledgeBase. Try running a CFG.')
            return []

        return [k for k,v in self.kb.functions.items() if not v.is_syscall and not v.is_simprocedure]


    @property
    def cfg_unnamed_node_addrs(self):
        """
        Returns a list of addresses: every node in the CFG that is unnamed (not part of a function)
        """
        if self.cfg is None:
            return []
        return [f.addr for f in self.cfg.nodes() if f.name is None ]

    def _get_funcs(self):
        # TODO: Remove excluded funcs
        # TODO: Only get 'sub_*' KB funcs
        sym_funcs = []
        kb_funcs  = []

        if self.use_sym is True:
            sym_funcs = [v for k,v in self.backend.symbols_by_addr.items() if v.is_function is True]
        if self.use_kb is True:
            kb_funcs = [v for k,v in self.kb.functions.items() if not v.is_syscall and not v.is_simprocedure and v.name.startswith('sub_')]

        # Two functions in a given FLIRT module are only differentiated by offset, so we
        # must always find the lowest one first since the modules are checked in their
        # natural, lower-to-higher offset, order.
        allfuncs = sorted(list(sym_funcs + kb_funcs), key=operator.attrgetter('addr'))
        l.debug(allfuncs)
        return allfuncs        # TODO: Parse/remove duplicates by addr

    def _get_addrs(self):   # TODO: Get KB/SYM addrs, as needed, or change to get_cfg_addrs
        """
        Returns the complete, sorted list of all addresses to scan based on provided options
        """
        sym_addrs = []
        kb_addrs  = []
        cfg_addrs = []

        #if self.use_sym is True:
        #    sym_addrs = self.sym_func_addrs
        #if self.use_kb is True:
        #    kb_addrs = self.kb_func_addrs
        if self.use_cfg_nodes is True:
            cfg_addrs = self.cfg_unnamed_node_addrs

        return sorted(set(self.user_addrs + self.exclude_addrs + sym_addrs + kb_addrs + cfg_addrs) \
                    - set(self.exclude_addrs))

    def scan(self):
        """
        Initiates the scan and returns a list of any matches found.
        """
        if self.scanner is not None:
            self.scanner.scan()
        else:
            l.error('No scanner specified.')

    def __repr__(self):
        scanner = self.scanner if self.scanner is not None else self
        return '<%s Signature Scan Result at %#x>' % (scanner._name, id(scanner))

class SigScanBase(object):
    def __init__(self, addrlist, funclist, bs, rename=False, cfg=None, kb=None, backend=None, offset=0, **kwargs):
        """
        :param addrlist:    The addresses to scan
        :param bs:          The binary stream (``file``) object to scan
        :param rename:      Whether or not to automatically rename matched functions in the kb.
                            Defaults to False.
        :param kb:          The Angr KnowledgeBase from which to pull function addresses for scanning
                            and, if specified, in which to rename matched functions.
        :param backend:     The CLE backend to analyze. Defaults to the project's main_object.
        :param offset:      Address offset, if the binary has been mapped into memory at an offset,
                            such as by Angr's CLE binary loader. Defaults to 0x0 in non-Project use
                            or to `binary.mapped_base` when used with an Angr Project.
        :param kwargs:      Various options for child classes
        """
        self.addrlist   = addrlist
        self.funclist   = funclist
        self.rename     = rename
        self.bs         = bs
        self.cfg        = cfg
        self.kb         = kb
        self.backend    = backend
        self.offset     = offset

        self.matches    = {}

        def scan(self):
            l.error('This method must be overridden by a child class which implements scanning.')
            pass

class FlirtScan(SigScanBase):
    """
    .. |nampa| replace:: :mod:`nampa`
    A wrapper around nampa to provide FLIRT signature scanning. This class
    may either be used as part of an angr Project (through `SigScan`) or used
    independently by supplying arguments (in kwargs) as defined in __init__().

    If used as an Angr project, see `SigScan`. If used independently, note the
    various Keyword Arguments that must be provided.
    """
    def __init__(self, addrlist, funclist, bs, rename=False, cfg=None, kb=None, backend=None, offset=0, **kwargs):
        super(FlirtScan, self).__init__(addrlist=addrlist, funclist=funclist, bs=bs, rename=rename, cfg=cfg, kb=kb, backend=backend, offset=offset, **kwargs)
        """
        :param sigpath:     Path to a FLIRT signature file or a directory. If a directory, only
                            files ending with `.sig` are considered. Defaults to ``os.getcwd()``.
        :param callback:    A function nampa calls for every match. Must be ``callback(addr, func)``.
                            Defaults to ``FlirtScan._nampa_callback``. This is used internally and
                            should only be specified if you wish to handle matches manually.

        :Example of non-Project Use:
        ```
        from angr.analyses.sigscan import FlirtScan
        bs = open('/home/user/program', 'rb')
        addrlist = [0x350, 0x493, 0x4ad, 0x4f7, 0x541]
        f = FlirtScan(addrlist=addrlist, bs=bs, rename=False, sigpath='/home/user/libc-2.22.sig')
        f.scan()
        print len(f.matches)
        ```
        """

        self.sigpath    = kwargs.get('sigpath', os.getcwd())
        #self.callback   = kwargs.get('callback', self._nampa_callback)
        self.callbacks = {'firstpass':  self._callback_first_pass,
                          'secondpass': self._callback_second_pass,}
                          #'matchrefs':  self._callback_match_refs }

        self.signatures = self._load_signatures(self.sigpath)
        self.ref_matches = {}
        self.refd_matches = {}
        self.created_kb_funcs = {}
        # TODO: HACK for nampa
        # The callback from nampa has to be a static method since it only
        # passes its `func` instance and the address, so we need to keep
        # a reference to the currently-running FlirtScan instance. We should
        # probably just put in a PR to add the ability to pass a **kwargs
        # param and we can pass the instance there.
        FlirtScan._cur_instance = self

    #
    # Static vars
    #
    _cur_instance   = None
    _FUNCTION_TAIL_LENGTH = 0x100


    @staticmethod
    def _old_nampa_callback(addr, func, matched_ref=False):
        """
        The callback for nampa to call on every matched function
        :param addr:    The offset of the function in the supplied buffer
        :param func:    A `nampa.FlirtFunction` object
        """
        fs      = FlirtScan._cur_instance
        kb      = fs.kb
        backend = fs.backend
        rename  = fs.rename
        duplicate = False

        #for m in fs.matches:
        #    if m.funcname == func.name: #or m.funcaddr == addr:
        #        duplicate = True
        #        l.warn('%s at 0x%08x is duplicate of %s at 0x%08x', func.name, addr, m.funcname, m.funcaddr)

        offaddr = addr + func.offset
        ref = func.refs_func.name if func.refs_func is not None else 'None'
        if fs._first_pass:
            l.debug('FIRSTPASS-CALLBACK: %s refs %s', func.name, ref)
        else:
            l.debug('SECONDPASS-CALLBACK: %s refs %s', func.name, ref)

        #if func.refs_func is None:
        for oldoffaddr,oldfunc in fs._matched_funcs.items():
            if func.name == oldfunc.name:
                l.debug('DUPLICATE: %s at 0x%04x was already found at 0x%04x.', func.name, offaddr, oldoffaddr)
                if not matched_ref:
                    return oldoffaddr
                #else:
                #    match = Match(func.name, offaddr, kb, backend, rename, duplicate, func)
                #    oldmatch = None
                #    for m in fs.matches:
                #        if m.funcname == match.funcname:
                #            m = match

        match = Match(func.name, offaddr, kb, backend, rename, duplicate, func)

        #l.debug('Matched (NOREF) %s at 0x%04x -- %s', func.name, offaddr, func)
        fs._matched_funcs[offaddr] = func
        fs.matches.append(match)
        return offaddr
        #else:
            #if offaddr not in self._matched_funcs:
            #    l.debug('Cannot confirm %s at 0x%04x. Refs %s at 0x%04x.', func.name, offaddr, func.refs_func.name, func.refs_func.addr)
            #    return False
            #else:
            #match = Match(func.name, offaddr, kb, backend, rename, duplicate, func)
            #l.debug('Matched (w/REF) %s at 0x%04x -- %s', func.name, offaddr, func)
            #fs._matched_funcs[offaddr] = func
            #fs.matches.append(match)
            #return True
    @staticmethod
    def _old_callback_second_pass(addr, func):
        fs      = FlirtScan._cur_instance
        offaddr = addr + func.offset
        ref = func.refs_func.name if func.refs_func is not None else 'None'
        l.debug('SECONDPASS-CALLBACK: %s [0x%04x] refs %s', func.name, offaddr, ref)

        if func.name in fs.matches:
            l.debug('SECONDPASS-CALLBACK: %s re-found in matches', func.name)

            oldoffaddr = fs.matches[func.name].funcaddr
            match = Match(func.name, oldoffaddr, fs.kb, fs.backend, fs.rename, True, func)
            fs.refd_matches[func.name] = match
            #fs.ref_matches[oldoffaddr] = func
            return oldoffaddr
        else:
            l.debug('SECONDPASS-CALLBACK: ****WHATSHAPPENING****')

    @staticmethod
    def _callback_match_refs(addr, func, refd_funcs):
        return
        fs      = FlirtScan._cur_instance
        l.debug('MATCHREF-CALLBACK: Checking %s. offset: 0x%04x, addr: 0x%04x', func.name, func.offset, addr)
        ref_addrs = []
        ref_funcs = []
        m = None
        try:
            m = fs.matches[func.name]
        except KeyError:
            offaddr = addr + func.offset
            l.debug('MATCHREF-CALLBACK: (NEW) %s at offaddr: 0x%04x', func.name, offaddr)
            fs.matches[func.name] = Match(func.name, offaddr, fs.kb, fs.backend, fs.rename, False, func)
        m = fs.matches[func.name]
        refmatch = fs.matches[func.refs_func.name]
        if refmatch.kbfunc is None:
            # TODO: HACK - Can't seem to generate a CFGFast with just a binary. It needs a project,
            # so we're depending on a KB's project existing here.
            fs.cfg.project.analyses.CFGFast(function_starts=[refmatch.funcaddr + refmatch.backend.mapped_base])
            refmatch.kbfunc = refmatch.kb.functions.function(addr=(refmatch.funcaddr + refmatch.backend.mapped_base), create=True)
            l.debug("%s refs %s. ref's kbfunc is %s", func.name, refmatch.funcname, refmatch.kbfunc.name)
        #return False
        ref_funcs.append(refmatch.kbfunc)
        for cs in m.kbfunc._call_sites.keys():
            ref_addrs.append(cs - fs.backend.mapped_base)
        if ref_addrs == []:
            l.debug('MATCHREF-CALLBACK: %s has no ref_addrs.', m.funcname)
        else:
            l.debug('MATCHREF-CALLBACK: %s has ref_addrs: %s', m.funcname, ''.join(['0x{:04X}, '.format(a) for a in ref_addrs]))


        if refmatch.funcaddr in ref_addrs:
            l.debug("Found 0x%04x in %s's ref_addrs", refmatch.funcaddr, refmatch.funcname)
            l.debug('----------------- END MATCHREF -----------------')
            return True
        else:
            l.debug("Failed to find 0x%04x in %s's ref_addrs", refmatch.funcaddr, refmatch.funcname)
            l.debug('----------------- END MATCHREF -----------------')
            return False

    def match_refs(self, addr, func):
        l.debug('MATCHREF-PUB: Checking %s. offset: 0x%04x, addr: 0x%04x', func.name, func.offset, addr)
        #for rf in refd_funcs:
        #    l.debug('MATCHREF-REF: Checking %s. offset: 0x%04x, addr: 0x%04x', rf.name, rf.offset, addr)

        offaddr = addr + func.offset

        match = Match(func.name, offaddr, self.kb, self.backend, self.rename, func.name in self.matches, func)
        self.ref_matches[func.name] = match
        kbf = match.kb_func
        if kbf is None:
            self.cfg.project.analyses.CFGFast(function_starts=[match.funcaddr + match.backend.mapped_base])
            kbf = match.kb_func
            l.debug('MATCHREF-PUB: Created kbf: %s', kbf)

        return


    @staticmethod
    def _callback_first_pass(addr, flirtfunc):
        """
        The callback for nampa to call on every matched function
        :param addr:    The offset of the function in the supplied buffer
        :param func:    A `nampa.FlirtFunction` object
        """
        fs      = FlirtScan._cur_instance

        offaddr = addr + flirtfunc.offset
        refdby = flirtfunc.refd_by.name if flirtfunc.refd_by is not None else 'None'
        l.debug('FIRSTPASSCALLBACK: %s [0x%04x] refd by %s', flirtfunc.name, addr, refdby)

        if flirtfunc.name in fs.matches:
            return False

        match = Match(flirtfunc.name, offaddr, fs.kb, fs.backend, fs.rename, False, flirtfunc)
        kbf = match.kb_func
        if kbf is None:
            fs.cfg.project.analyses.CFGFast(function_starts=[offaddr + match.backend.mapped_base])
            kbf = match.kb_func
            l.debug('FIRSTPASSCALLBACK: Created kbf: %s', kbf)
            fs.created_kb_funcs[kbf.addr] = kbf
            if kbf is None:
                l.error('FIRSTPASSCALLBACK: Failed to create function in KB')

        kbf.name = flirtfunc.name

        fs.matches[flirtfunc.name] = match

        return True



    @staticmethod
    def _callback_second_pass(addr, flirtfunc):
        return
        """
        The callback for nampa to call on every matched function
        :param addr:    The offset of the function in the supplied buffer
        :param func:    A `nampa.FlirtFunction` object
        """
        fs      = FlirtScan._cur_instance
        offaddr = addr + flirtfunc.offset
        ref = flirtfunc.refs_func.name if flirtfunc.refs_func is not None else 'None'
        l.debug('SECONDPASSCALLBACK: %s [0x%04x] refs %s', flirtfunc.name, addr, ref)


        #if flirtfunc.refd_by is None:
        #    if flirtfunc.name in fs.ref_matches:
        #        return False

        match = Match(flirtfunc.name, offaddr, fs.kb, fs.backend, fs.rename, False, flirtfunc)
        kbf = match.kb_func
        #if kbf is None:
            #fs.cfg.project.analyses.CFGFast(function_starts=[offaddr + match.backend.mapped_base])
            #kbf = match.kb_func
            #l.debug('SECONDPASSCALLBACK: Created kbf: %s', kbf)
            #if kbf is None:
            #    l.error('SECONDPASSCALLBACK: Failed to create function in KB')
        l.debug('SECONDPASSCALLBACK: %s kbf_func is: %s', flirtfunc.name, kbf)

        #fs.matches[flirtfunc.name] = match
        l.debug('SECONDPASSCALLBACK: Match: %s', match)
        #return offaddr
        return False # Always let the scanner continue, in case there's a better match further on

    def scan(self):
        #self._match_addrs(self.addrlist, self.offset)
        self._match_funcs(self.funclist, self.offset)
        FlirtScan._cur_instance = None

    def _load_signatures(self, sigpath):
        sigfiles = []
        if os.path.isfile(sigpath):
            sigfiles.append(sigpath)
        elif os.path.isdir(sigpath):
            sigfiles.extend([os.path.join(sigpath, f) for f in next(os.walk(sigpath))[2] if f.endswith('.sig')])

        signatures = []
        for sf in sigfiles:
            with open(sf, 'rb') as sigfile:
                signatures.append(nampa.parse_flirt_file(sigfile))

        return signatures

    def _match_addrs(self, addrlist, offset):
        for s in self.signatures:
            l.info("Scanning %d addresses for signatures in '%s'", len(addrlist), s.header.library_name)
            for addr in addrlist:
                l.debug('Checking 0x%08x', addr)
                start = addr - offset   # Removing the mapped_base
                end = addr + 400        # TODO: HACK. Get function's actual size
                self.bs.seek(start, 0)
                buf = self.bs.read(end - start + FlirtScan._FUNCTION_TAIL_LENGTH)
                nampa.match_function(s, buf, start, self.callback)

    def _match_funcs(self, funclist, offset):
        for s in self.signatures:
            l.debug('************** FIRST PASS SCAN **************')
            l.info("Scanning %d funcs for signatures in '%s'", len(funclist), s.header.library_name)
            for func in funclist:
                l.debug('Checking %s', func.name)
                if self._match_funcs_first_pass(s, func, offset):
                    l.debug('************** SECOND PASS SCAN **************')
                    self._match_funcs_second_pass(s, func, offset)

            l.debug('************** SECOND PASS SCAN **************')
            for func in funclist:
                self._match_funcs_second_pass(s, func, offset)

            l.debug('Fixing CFG...')
            self.cfg.project.analyses.CFGFast(function_starts=self.created_kb_funcs.keys())


    def _match_funcs_second_pass(self, sig, func, offset):
        addr = func.addr        # TODO: Check for relative_addr (and/or change that name in the KB)
        l.debug('Checking 0x%08x', addr)
        start = addr - offset   # Removing the mapped_base
        end = start + func.size
        self.bs.seek(start, 0)
        buf = self.bs.read(end - start + FlirtScan._FUNCTION_TAIL_LENGTH)

        nampa.match_function(sig, buf, start, self.callbacks, False)


    def _match_funcs_first_pass(self, sig, func, offset): #TODO: Just take KB instead of funclist. Check all sub_*
        addrlist = func._addr_to_block_node.keys()
        #addrlist.remove(func.addr)  # If the ref functions were unrecognized, we need to find them first
                                    # without potentially erroneous matches for the function itself
        for addr in addrlist:
            l.debug('Checking 0x%08x', addr)
            start = addr - offset   # Removing the mapped_base
            end = start + func.size
            self.bs.seek(start, 0)
            buf = self.bs.read(end - start + FlirtScan._FUNCTION_TAIL_LENGTH)

            nampa.match_function(sig, buf, start, self.callbacks, True)



                #if first_pass:
                #    self._match_funcs(funclist, offset, False)
            #if first_pass:
            #    ref_funcs = []
            #    for m in [mr for mr in self.matches if mr.flirtfunc.refs_func is not None]:
            #        ref_funcs.append(m.kbfunc)
            #        for cs in m.kbfunc._call_sites.keys():
            #            ref_addrs.append(cs - offset)
            #    self._match_funcs(ref_funcs, offset, get_refs, sorted(set(ref_addrs)))
                #for offaddr,func in self._matched_funcs.items():
                #    print '---- Remove %s at 0x%08x for second pass' % (func.name, offaddr)
                #    pass2funcs = [f for f in funclist if f not in no_match_funcs]

                #self._match_funcs(pass2funcs, offset, get_refs)

register_analysis(SigScan, 'SigScan')

registered_signature_scanners = {}

def register_signature_scanner(cls, name):
    registered_signature_scanners[name] = cls

register_signature_scanner(FlirtScan, 'flirt')
